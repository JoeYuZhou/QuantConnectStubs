# encoding: utf-8
# module QuantConnect.Data calls itself Data
# from QuantConnect.Common, Version=2.4.0.0, Culture=neutral, PublicKeyToken=null
# by generator 1.145
# no doc
# no imports

# no functions
# classes

class BaseData(object, IBaseData):
    """
    Abstract base data class of QuantConnect. It is intended to be extended to define
                generic user customizable data types while at the same time implementing the basics of data where possible
    
    BaseData()
    """
    def Clone(self, fillForward=None):
        """
        Clone(self: BaseData, fillForward: bool) -> BaseData
        
            Return a new instance clone of this object, used 
             in fill forward
        
        
            fillForward: True if this is a fill forward clone
            Returns: A clone of the current object
        Clone(self: BaseData) -> BaseData
        
            Return a new instance clone of this object, used 
             in fill forward
        
            Returns: A clone of the current object
        """
        pass

    def DataTimeZone(self):
        """
        DataTimeZone(self: BaseData) -> DateTimeZone
        
            Specifies the data time zone for this data type. 
             This is useful for custom data types
        
            Returns: The NodaTime.DateTimeZone of this data type
        """
        pass

    def DefaultResolution(self):
        """
        DefaultResolution(self: BaseData) -> Resolution
        
            Gets the default resolution for this data and 
             security type
        """
        pass

    @staticmethod
    def DeserializeMessage(serialized):
        """
        DeserializeMessage(serialized: str) -> IEnumerable[BaseData]
        
            Deserialize the message from the data server
        
            serialized: The data server's message
            Returns: An enumerable of base data, if unsuccessful, 
             returns an empty enumerable
        """
        pass

    def GetSource(self, config, date, *__args):
        """
        GetSource(self: BaseData, config: SubscriptionDataConfig, date: DateTime, isLiveMode: bool) -> SubscriptionDataSource
        
            Return the URL string source of the file. This 
             will be converted to a stream
        
        
            config: Configuration object
            date: Date of this source file
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: String URL of source file.
        GetSource(self: BaseData, config: SubscriptionDataConfig, date: DateTime, datafeed: DataFeedEndpoint) -> str
        
            Return the URL string source of the file. This 
             will be converted to a stream
        
        
            config: Configuration object
            date: Date of this source file
            datafeed: Type of datafeed we're reqesting - backtest or 
             live
        
            Returns: String URL of source file.
        """
        pass

    def IsSparseData(self):
        """
        IsSparseData(self: BaseData) -> bool
        
            Indicates that the data set is expected to be 
             sparse
        
            Returns: True if the data set represented by this type is 
             expected to be sparse
        """
        pass

    def Reader(self, config, *__args):
        """
        Reader(self: BaseData, config: SubscriptionDataConfig, line: str, date: DateTime, isLiveMode: bool) -> BaseData
        
            Reader converts each line of the data source into 
             BaseData objects. Each data type creates its own 
             factory method, and returns a new instance of the 
             object
                    each time it is called. The 
             returned object is assumed to be time stamped in 
             the config.ExchangeTimeZone.
        
        
            config: Subscription data config setup object
            line: Line of the source document
            date: Date of the requested data
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: Instance of the T:BaseData object generated by 
             this line of the CSV
        
        Reader(self: BaseData, config: SubscriptionDataConfig, stream: StreamReader, date: DateTime, isLiveMode: bool) -> BaseData
        
            Reader converts each line of the data source into 
             BaseData objects. Each data type creates its own 
             factory method, and returns a new instance of the 
             object
                    each time it is called. The 
             returned object is assumed to be time stamped in 
             the config.ExchangeTimeZone.
        
        
            config: Subscription data config setup object
            stream: The data stream
            date: Date of the requested data
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: Instance of the T:BaseData object generated by 
             this line of the CSV
        
        Reader(self: BaseData, config: SubscriptionDataConfig, line: str, date: DateTime, datafeed: DataFeedEndpoint) -> BaseData
        
            Reader converts each line of the data source into 
             BaseData objects. Each data type creates its own 
             factory method, and returns a new instance of the 
             object
                    each time it is called.
        
        
            config: Subscription data config setup object
            line: Line of the source document
            date: Date of the requested data
            datafeed: Type of datafeed we're requesting - a live or 
             backtest feed.
        
            Returns: Instance of the T:BaseData object generated by 
             this line of the CSV
        """
        pass

    def RequiresMapping(self):
        """
        RequiresMapping(self: BaseData) -> bool
        
            Indicates if there is support for mapping
            Returns: True indicates mapping should be used
        """
        pass

    def SupportedResolutions(self):
        """
        SupportedResolutions(self: BaseData) -> List[Resolution]
        
            Gets the supported resolution for this data and 
             security type
        """
        pass

    def ToString(self):
        """
        ToString(self: BaseData) -> str
        
            Formats a string with the symbol and value.
            Returns: string - a string formatted as SPY: 167.753
        """
        pass

    def Update(self, lastTrade, bidPrice, askPrice, volume, bidSize, askSize):
        """
        Update(self: BaseData, lastTrade: Decimal, bidPrice: Decimal, askPrice: Decimal, volume: Decimal, bidSize: Decimal, askSize: Decimal)
            Update routine to build a bar/tick from a data 
             update.
        
        
            lastTrade: The last trade price
            bidPrice: Current bid price
            askPrice: Current asking price
            volume: Volume of this trade
            bidSize: The size of the current bid, if available
            askSize: The size of the current ask, if available
        """
        pass

    def UpdateAsk(self, askPrice, askSize):
        """
        UpdateAsk(self: BaseData, askPrice: Decimal, askSize: Decimal)
            Updates this base data with the new quote ask 
             information
        
        
            askPrice: The current ask price
            askSize: The current ask size
        """
        pass

    def UpdateBid(self, bidPrice, bidSize):
        """
        UpdateBid(self: BaseData, bidPrice: Decimal, bidSize: Decimal)
            Updates this base data with the new quote bid 
             information
        
        
            bidPrice: The current bid price
            bidSize: The current bid size
        """
        pass

    def UpdateQuote(self, bidPrice, bidSize, askPrice, askSize):
        """
        UpdateQuote(self: BaseData, bidPrice: Decimal, bidSize: Decimal, askPrice: Decimal, askSize: Decimal)
            Updates this base data with new quote information
        
            bidPrice: The current bid price
            bidSize: The current bid size
            askPrice: The current ask price
            askSize: The current ask size
        """
        pass

    def UpdateTrade(self, lastTrade, tradeSize):
        """
        UpdateTrade(self: BaseData, lastTrade: Decimal, tradeSize: Decimal)
            Updates this base data with a new trade
        
            lastTrade: The price of the last trade
            tradeSize: The quantity traded
        """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __repr__(self, *args): #cannot find CLR method
        """ __repr__(self: object) -> str """
        pass

    def __str__(self, *args): #cannot find CLR method
        pass

    DataType = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Market Data Type of this data - does it come in individual price packets or is it grouped into OHLC.

Get: DataType(self: BaseData) -> MarketDataType

Set: DataType(self: BaseData) = value
"""

    EndTime = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The end time of this data. Some data covers spans (trade bars) and as such we want
            to know the entire time span covered

Get: EndTime(self: BaseData) -> DateTime

Set: EndTime(self: BaseData) = value
"""

    IsFillForward = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """True if this is a fill forward piece of data

Get: IsFillForward(self: BaseData) -> bool

"""

    Price = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """As this is a backtesting platform we'll provide an alias of value as price.

Get: Price(self: BaseData) -> Decimal

"""

    Symbol = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Symbol representation for underlying Security

Get: Symbol(self: BaseData) -> Symbol

Set: Symbol(self: BaseData) = value
"""

    Time = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Current time marker of this data packet.

Get: Time(self: BaseData) -> DateTime

Set: Time(self: BaseData) = value
"""

    Value = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Value representation of this data packet. All data requires a representative value for this moment in time.
            For streams of data this is the price now, for OHLC packets this is the closing price.

Get: Value(self: BaseData) -> Decimal

Set: Value(self: BaseData) = value
"""


    AllResolutions = None
    DailyResolution = None
    MinuteResolution = None


class DynamicData(BaseData, IBaseData, IDynamicMetaObjectProvider):
    """ Dynamic Data Class: Accept flexible data, adapting to the columns provided by source. """
    def Clone(self, fillForward=None):
        """
        Clone(self: DynamicData) -> BaseData
        
            Return a new instance clone of this object, used 
             in fill forward
        
            Returns: A clone of the current object
        """
        pass

    def GetMetaObject(self, parameter):
        """
        GetMetaObject(self: DynamicData, parameter: Expression) -> DynamicMetaObject
        
            Get the metaObject required for Dynamism.
        """
        pass

    def GetProperty(self, name):
        """
        GetProperty(self: DynamicData, name: str) -> object
        
            Gets the property's value with the specified 
             name. This is a case-insensitve search.
        
        
            name: The property name to access
            Returns: object value of BaseData
        """
        pass

    def GetStorageDictionary(self):
        """
        GetStorageDictionary(self: DynamicData) -> IDictionary[str, object]
        
            Gets the storage dictionary
                    Python 
             algorithms need this information since 
             DynamicMetaObject does not work
        
            Returns: Dictionary that stores the paramenters names and 
             values
        """
        pass

    def HasProperty(self, name):
        """
        HasProperty(self: DynamicData, name: str) -> bool
        
            Gets whether or not this dynamic data instance 
             has a property with the specified name.
                 
                This is a case-insensitve search.
        
        
            name: The property name to check for
            Returns: True if the property exists, false otherwise
        """
        pass

    def SetProperty(self, name, value):
        """
        SetProperty(self: DynamicData, name: str, value: object) -> object
        
            Sets the property with the specified name to the 
             value. This is a case-insensitve search.
        
        
            name: The property name to set
            value: The new property value
            Returns: Returns the input value back to the caller
        """
        pass

    def __dir__(self, *args): #cannot find CLR method
        """ __dir__(self: IDynamicMetaObjectProvider) -> list """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __str__(self, *args): #cannot find CLR method
        pass


class FileFormat(Enum, IComparable, IFormattable, IConvertible):
    """
    Specifies the format of data in a subscription
    
    enum FileFormat, values: Binary (1), Collection (3), Csv (0), Index (4), ZipEntryName (2)
    """
    def __eq__(self, *args): #cannot find CLR method
        """ x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y """
        pass

    def __format__(self, *args): #cannot find CLR method
        """ __format__(formattable: IFormattable, format: str) -> str """
        pass

    def __ge__(self, *args): #cannot find CLR method
        pass

    def __gt__(self, *args): #cannot find CLR method
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __le__(self, *args): #cannot find CLR method
        pass

    def __lt__(self, *args): #cannot find CLR method
        pass

    def __ne__(self, *args): #cannot find CLR method
        pass

    def __reduce_ex__(self, *args): #cannot find CLR method
        pass

    def __str__(self, *args): #cannot find CLR method
        pass

    Binary = None
    Collection = None
    Csv = None
    Index = None
    value__ = None
    ZipEntryName = None


class GetSetPropertyDynamicMetaObject(DynamicMetaObject):
    """
    Provides an implementation of System.Dynamic.DynamicMetaObject that uses get/set methods to update
                values in the dynamic object.
    
    GetSetPropertyDynamicMetaObject(expression: Expression, value: object, setPropertyMethodInfo: MethodInfo, getPropertyMethodInfo: MethodInfo)
    """
    def BindGetMember(self, binder):
        """ BindGetMember(self: GetSetPropertyDynamicMetaObject, binder: GetMemberBinder) -> DynamicMetaObject """
        pass

    def BindSetMember(self, binder, value):
        """ BindSetMember(self: GetSetPropertyDynamicMetaObject, binder: SetMemberBinder, value: DynamicMetaObject) -> DynamicMetaObject """
        pass

    @staticmethod # known case of __new__
    def __new__(self, expression, value, setPropertyMethodInfo, getPropertyMethodInfo):
        """ __new__(cls: type, expression: Expression, value: object, setPropertyMethodInfo: MethodInfo, getPropertyMethodInfo: MethodInfo) """
        pass


class HistoryProviderBase(object, IHistoryProvider, IDataProviderEvents):
    """ Provides a base type for all history providers """
    def GetHistory(self, requests, sliceTimeZone):
        """ GetHistory(self: HistoryProviderBase, requests: IEnumerable[HistoryRequest], sliceTimeZone: DateTimeZone) -> IEnumerable[Slice] """
        pass

    def Initialize(self, parameters):
        """
        Initialize(self: HistoryProviderBase, parameters: HistoryProviderInitializeParameters)
            Initializes this history provider to work for the 
             specified job
        
        
            parameters: The initialization parameters
        """
        pass

    def OnDownloadFailed(self, *args): #cannot find CLR method
        """
        OnDownloadFailed(self: HistoryProviderBase, e: DownloadFailedEventArgs)
            Event invocator for the 
             QuantConnect.Data.HistoryProviderBase.DownloadFail
             ed event
        
        
            e: Event arguments for the 
             QuantConnect.Data.HistoryProviderBase.DownloadFail
             ed event
        """
        pass

    def OnInvalidConfigurationDetected(self, *args): #cannot find CLR method
        """
        OnInvalidConfigurationDetected(self: HistoryProviderBase, e: InvalidConfigurationDetectedEventArgs)
            Event invocator for the 
             QuantConnect.Data.HistoryProviderBase.InvalidConfi
             gurationDetected event
        
        
            e: Event arguments for the 
             QuantConnect.Data.HistoryProviderBase.InvalidConfi
             gurationDetected event
        """
        pass

    def OnNumericalPrecisionLimited(self, *args): #cannot find CLR method
        """
        OnNumericalPrecisionLimited(self: HistoryProviderBase, e: NumericalPrecisionLimitedEventArgs)
            Event invocator for the 
             QuantConnect.Data.HistoryProviderBase.NumericalPre
             cisionLimited event
        
        
            e: Event arguments for the 
             QuantConnect.Data.HistoryProviderBase.NumericalPre
             cisionLimited event
        """
        pass

    def OnReaderErrorDetected(self, *args): #cannot find CLR method
        """
        OnReaderErrorDetected(self: HistoryProviderBase, e: ReaderErrorDetectedEventArgs)
            Event invocator for the 
             QuantConnect.Data.HistoryProviderBase.ReaderErrorD
             etected event
        
        
            e: Event arguments for the 
             QuantConnect.Data.HistoryProviderBase.ReaderErrorD
             etected event
        """
        pass

    def OnStartDateLimited(self, *args): #cannot find CLR method
        """
        OnStartDateLimited(self: HistoryProviderBase, e: StartDateLimitedEventArgs)
            Event invocator for the 
             QuantConnect.Data.HistoryProviderBase.StartDateLim
             ited event
        
        
            e: Event arguments for the 
             QuantConnect.Data.HistoryProviderBase.StartDateLim
             ited event
        """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __repr__(self, *args): #cannot find CLR method
        """ __repr__(self: object) -> str """
        pass

    DataPointCount = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the total number of data points emitted by this history provider

Get: DataPointCount(self: HistoryProviderBase) -> int

"""


    DownloadFailed = None
    InvalidConfigurationDetected = None
    NumericalPrecisionLimited = None
    ReaderErrorDetected = None
    StartDateLimited = None


class HistoryProviderInitializeParameters(object):
    """
    Represents the set of parameters for the QuantConnect.Interfaces.IHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters) method
    
    HistoryProviderInitializeParameters(job: AlgorithmNodePacket, api: IApi, dataProvider: IDataProvider, dataCacheProvider: IDataCacheProvider, mapFileProvider: IMapFileProvider, factorFileProvider: IFactorFileProvider, statusUpdateAction: Action[int], parallelHistoryRequestsEnabled: bool, dataPermissionManager: IDataPermissionManager)
    """
    @staticmethod # known case of __new__
    def __new__(self, job, api, dataProvider, dataCacheProvider, mapFileProvider, factorFileProvider, statusUpdateAction, parallelHistoryRequestsEnabled, dataPermissionManager):
        """ __new__(cls: type, job: AlgorithmNodePacket, api: IApi, dataProvider: IDataProvider, dataCacheProvider: IDataCacheProvider, mapFileProvider: IMapFileProvider, factorFileProvider: IFactorFileProvider, statusUpdateAction: Action[int], parallelHistoryRequestsEnabled: bool, dataPermissionManager: IDataPermissionManager) """
        pass

    Api = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The API instance

Get: Api(self: HistoryProviderInitializeParameters) -> IApi

"""

    DataCacheProvider = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The provider used to cache history data files

Get: DataCacheProvider(self: HistoryProviderInitializeParameters) -> IDataCacheProvider

"""

    DataPermissionManager = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The data permission manager

Get: DataPermissionManager(self: HistoryProviderInitializeParameters) -> IDataPermissionManager

"""

    DataProvider = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The provider used to get data when it is not present on disk

Get: DataProvider(self: HistoryProviderInitializeParameters) -> IDataProvider

"""

    FactorFileProvider = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The provider used to get factor files to handle equity price scaling

Get: FactorFileProvider(self: HistoryProviderInitializeParameters) -> IFactorFileProvider

"""

    Job = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The job

Get: Job(self: HistoryProviderInitializeParameters) -> AlgorithmNodePacket

"""

    MapFileProvider = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The provider used to get a map file resolver to handle equity mapping

Get: MapFileProvider(self: HistoryProviderInitializeParameters) -> IMapFileProvider

"""

    ParallelHistoryRequestsEnabled = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """True if parallel history requests are enabled

Get: ParallelHistoryRequestsEnabled(self: HistoryProviderInitializeParameters) -> bool

"""

    StatusUpdateAction = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """A function used to send status updates

Get: StatusUpdateAction(self: HistoryProviderInitializeParameters) -> Action[int]

"""



class HistoryRequest(object):
    """
    Represents a request for historical data
    
    HistoryRequest(startTimeUtc: DateTime, endTimeUtc: DateTime, dataType: Type, symbol: Symbol, resolution: Resolution, exchangeHours: SecurityExchangeHours, dataTimeZone: DateTimeZone, fillForwardResolution: Nullable[Resolution], includeExtendedMarketHours: bool, isCustomData: bool, dataNormalizationMode: DataNormalizationMode, tickType: TickType)
    HistoryRequest(config: SubscriptionDataConfig, hours: SecurityExchangeHours, startTimeUtc: DateTime, endTimeUtc: DateTime)
    """
    @staticmethod # known case of __new__
    def __new__(self, *__args):
        """
        __new__(cls: type, startTimeUtc: DateTime, endTimeUtc: DateTime, dataType: Type, symbol: Symbol, resolution: Resolution, exchangeHours: SecurityExchangeHours, dataTimeZone: DateTimeZone, fillForwardResolution: Nullable[Resolution], includeExtendedMarketHours: bool, isCustomData: bool, dataNormalizationMode: DataNormalizationMode, tickType: TickType)
        __new__(cls: type, config: SubscriptionDataConfig, hours: SecurityExchangeHours, startTimeUtc: DateTime, endTimeUtc: DateTime)
        """
        pass

    DataNormalizationMode = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the normalization mode used for this subscription

Get: DataNormalizationMode(self: HistoryRequest) -> DataNormalizationMode

Set: DataNormalizationMode(self: HistoryRequest) = value
"""

    DataTimeZone = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the time zone of the time stamps on the raw input data

Get: DataTimeZone(self: HistoryRequest) -> DateTimeZone

Set: DataTimeZone(self: HistoryRequest) = value
"""

    DataType = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the data type used to process the subscription request, this type must derive from BaseData

Get: DataType(self: HistoryRequest) -> Type

Set: DataType(self: HistoryRequest) = value
"""

    EndTimeUtc = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the end time of the request.

Get: EndTimeUtc(self: HistoryRequest) -> DateTime

Set: EndTimeUtc(self: HistoryRequest) = value
"""

    ExchangeHours = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the exchange hours used for processing fill forward requests

Get: ExchangeHours(self: HistoryRequest) -> SecurityExchangeHours

Set: ExchangeHours(self: HistoryRequest) = value
"""

    FillForwardResolution = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the requested fill forward resolution, set to null for no fill forward behavior.
            Will always return null when Resolution is set to Tick.

Get: FillForwardResolution(self: HistoryRequest) -> Nullable[Resolution]

Set: FillForwardResolution(self: HistoryRequest) = value
"""

    IncludeExtendedMarketHours = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets whether or not to include extended market hours data, set to false for only normal market hours

Get: IncludeExtendedMarketHours(self: HistoryRequest) -> bool

Set: IncludeExtendedMarketHours(self: HistoryRequest) = value
"""

    IsCustomData = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets true if this is a custom data request, false for normal QC data

Get: IsCustomData(self: HistoryRequest) -> bool

Set: IsCustomData(self: HistoryRequest) = value
"""

    Resolution = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the requested data resolution

Get: Resolution(self: HistoryRequest) -> Resolution

Set: Resolution(self: HistoryRequest) = value
"""

    StartTimeUtc = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the start time of the request.

Get: StartTimeUtc(self: HistoryRequest) -> DateTime

Set: StartTimeUtc(self: HistoryRequest) = value
"""

    Symbol = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the symbol to request data for

Get: Symbol(self: HistoryRequest) -> Symbol

Set: Symbol(self: HistoryRequest) = value
"""

    TickType = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """TickType of the history request

Get: TickType(self: HistoryRequest) -> TickType

Set: TickType(self: HistoryRequest) = value
"""



class HistoryRequestFactory(object):
    """
    Helper class used to create new QuantConnect.Data.HistoryRequest
    
    HistoryRequestFactory(algorithm: IAlgorithm)
    """
    def CreateHistoryRequest(self, subscription, startAlgoTz, endAlgoTz, exchangeHours, resolution):
        """ CreateHistoryRequest(self: HistoryRequestFactory, subscription: SubscriptionDataConfig, startAlgoTz: DateTime, endAlgoTz: DateTime, exchangeHours: SecurityExchangeHours, resolution: Nullable[Resolution]) -> HistoryRequest """
        pass

    def GetStartTimeAlgoTz(self, symbol, periods, resolution, exchange):
        """
        GetStartTimeAlgoTz(self: HistoryRequestFactory, symbol: Symbol, periods: int, resolution: Resolution, exchange: SecurityExchangeHours) -> DateTime
        
            Gets the start time required for the specified 
             bar count in terms of the algorithm's time zone
        
        
            symbol: The symbol to select proper 
             QuantConnect.Data.SubscriptionDataConfig config
        
            periods: The number of bars requested
            resolution: The length of each bar
            exchange: The exchange hours used for market open hours
            Returns: The start time that would provide the specified 
             number of bars ending at the algorithm's current 
             time
        """
        pass

    @staticmethod # known case of __new__
    def __new__(self, algorithm):
        """ __new__(cls: type, algorithm: IAlgorithm) """
        pass


class IBaseData:
    """ Base Data Class: Type, Timestamp, Key -- Base Features. """
    def Clone(self):
        """
        Clone(self: IBaseData) -> BaseData
        
            Return a new instance clone of this object
        """
        pass

    def GetSource(self, config, date, datafeed):
        """
        GetSource(self: IBaseData, config: SubscriptionDataConfig, date: DateTime, datafeed: DataFeedEndpoint) -> str
        
            Return the URL string source of the file. This 
             will be converted to a stream
        
        
            config: Configuration object
            date: Date of this source file
            datafeed: Type of datafeed we're reqesting - backtest or 
             live
        
            Returns: String URL of source file.
        """
        pass

    def Reader(self, config, *__args):
        """
        Reader(self: IBaseData, config: SubscriptionDataConfig, line: str, date: DateTime, dataFeed: DataFeedEndpoint) -> BaseData
        
            Reader Method :: using set of arguements we 
             specify read out type. Enumerate
                    
             until the end of the data stream or file. E.g. 
             Read CSV file line by line and convert
                  
               into data types.
        
            Returns: BaseData type set by Subscription Method.
        Reader(self: IBaseData, config: SubscriptionDataConfig, line: str, date: DateTime, isLiveMode: bool) -> BaseData
        
            Reader converts each line of the data source into 
             BaseData objects. Each data type creates its own 
             factory method, and returns a new instance of the 
             object
                    each time it is called. The 
             returned object is assumed to be time stamped in 
             the config.ExchangeTimeZone.
        
        
            config: Subscription data config setup object
            line: Line of the source document
            date: Date of the requested data
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: Instance of the T:BaseData object generated by 
             this line of the CSV
        
        Reader(self: IBaseData, config: SubscriptionDataConfig, stream: StreamReader, date: DateTime, isLiveMode: bool) -> BaseData
        
            Reader converts each line of the data source into 
             BaseData objects. Each data type creates its own 
             factory method, and returns a new instance of the 
             object
                    each time it is called. The 
             returned object is assumed to be time stamped in 
             the config.ExchangeTimeZone.
        
        
            config: Subscription data config setup object
            stream: The data stream
            date: Date of the requested data
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: Instance of the T:BaseData object generated by 
             this line of the CSV
        """
        pass

    def RequiresMapping(self):
        """
        RequiresMapping(self: IBaseData) -> bool
        
            Indicates if there is support for mapping
            Returns: True indicates mapping should be used
        """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    DataType = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Market Data Type of this data - does it come in individual price packets or is it grouped into OHLC.

Get: DataType(self: IBaseData) -> MarketDataType

Set: DataType(self: IBaseData) = value
"""

    EndTime = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Get: EndTime(self: IBaseData) -> DateTime

Set: EndTime(self: IBaseData) = value
"""

    Price = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Alias of Value.

Get: Price(self: IBaseData) -> Decimal

"""

    Symbol = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Symbol for underlying Security

Get: Symbol(self: IBaseData) -> Symbol

Set: Symbol(self: IBaseData) = value
"""

    Time = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Time keeper of data -- all data is timeseries based.

Get: Time(self: IBaseData) -> DateTime

Set: Time(self: IBaseData) = value
"""

    Value = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """All timeseries data is a time-value pair:

Get: Value(self: IBaseData) -> Decimal

Set: Value(self: IBaseData) = value
"""



class IndexedBaseData(BaseData, IBaseData):
    """
    Abstract indexed base data class of QuantConnect.
                It is intended to be extended to define customizable data types which are stored
                using an intermediate index source
    """
    def GetSource(self, config, date, *__args):
        """
        GetSource(self: IndexedBaseData, config: SubscriptionDataConfig, date: DateTime, isLiveMode: bool) -> SubscriptionDataSource
        
            Returns the index source for a date
        
            config: Configuration object
            date: Date of this source file
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: The QuantConnect.Data.SubscriptionDataSource 
             instance to use
        """
        pass

    def GetSourceForAnIndex(self, config, date, index, isLiveMode):
        """
        GetSourceForAnIndex(self: IndexedBaseData, config: SubscriptionDataConfig, date: DateTime, index: str, isLiveMode: bool) -> SubscriptionDataSource
        
            Returns the source for a given index value
        
            config: Configuration object
            date: Date of this source file
            index: The index value for which we want to fetch the 
             source
        
            isLiveMode: true if we're in live mode, false for backtesting 
             mode
        
            Returns: The QuantConnect.Data.SubscriptionDataSource 
             instance to use
        """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __str__(self, *args): #cannot find CLR method
        pass


class ISubscriptionEnumeratorFactory:
    """ Create an System.Collections.Generic.IEnumerator """
    def CreateEnumerator(self, request, dataProvider):
        """
        CreateEnumerator(self: ISubscriptionEnumeratorFactory, request: SubscriptionRequest, dataProvider: IDataProvider) -> IEnumerator[BaseData]
        
            Creates an enumerator to read the specified 
             request
        
        
            request: The subscription request to be read
            dataProvider: Provider used to get data when it is not present 
             on disk
        
            Returns: An enumerator reading the subscription request
        """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass


class Slice(ExtendedDictionary[object], IExtendedDictionary[Symbol, object], IEnumerable[KeyValuePair[Symbol, BaseData]], IEnumerable):
    """
    Provides a data structure for all of an algorithm's data at a single time step
    
    Slice(time: DateTime, data: IEnumerable[BaseData])
    Slice(time: DateTime, data: List[BaseData])
    Slice(time: DateTime, data: IEnumerable[BaseData], tradeBars: TradeBars, quoteBars: QuoteBars, ticks: Ticks, optionChains: OptionChains, futuresChains: FuturesChains, splits: Splits, dividends: Dividends, delistings: Delistings, symbolChanges: SymbolChangedEvents, hasData: Nullable[bool])
    """
    def ContainsKey(self, symbol):
        """
        ContainsKey(self: Slice, symbol: Symbol) -> bool
        
            Determines whether this instance contains data 
             for the specified symbol
        
        
            symbol: The symbol we seek data for
            Returns: True if this instance contains data for the 
             symbol, false otherwise
        """
        pass

    def Get(self, *__args):
# Error generating skeleton for function Get: Method must be called on a Type for which Type.IsGenericParameter is false.

    def GetEnumerator(self):
        """
        GetEnumerator(self: Slice) -> IEnumerator[KeyValuePair[Symbol, BaseData]]
        
            Returns an enumerator that iterates through the 
             collection.
        
            Returns: A System.Collections.Generic.IEnumerator that can 
             be used to iterate through the collection.
        """
        pass

    def GetImpl(self, *args): #cannot find CLR method
        """
        GetImpl(type: Type, instance: Slice) -> object
        
            Gets the data of the specified type.
        """
        pass

    def TryGetValue(self, symbol, data):
        """
        TryGetValue(self: Slice, symbol: Symbol) -> (bool, object)
        
            Gets the data associated with the specified symbol
        
            symbol: The symbol we want data for
            Returns: True if data was found, false otherwise
        """
        pass

    def __contains__(self, *args): #cannot find CLR method
        """ __contains__[KeyValuePair[Symbol, BaseData]](enumerable: IEnumerable[KeyValuePair[Symbol, BaseData]], value: KeyValuePair[Symbol, BaseData]) -> bool """
        pass

    def __getitem__(self, *args): #cannot find CLR method
        """ x.__getitem__(y) <==> x[y] """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __iter__(self, *args): #cannot find CLR method
        """ __iter__(self: IEnumerable) -> object """
        pass

    @staticmethod # known case of __new__
    def __new__(self, time, data, tradeBars=None, quoteBars=None, ticks=None, optionChains=None, futuresChains=None, splits=None, dividends=None, delistings=None, symbolChanges=None, hasData=None):
        """
        __new__(cls: type, time: DateTime, data: IEnumerable[BaseData])
        __new__(cls: type, time: DateTime, data: List[BaseData])
        __new__(cls: type, slice: Slice)
        __new__(cls: type, time: DateTime, data: IEnumerable[BaseData], tradeBars: TradeBars, quoteBars: QuoteBars, ticks: Ticks, optionChains: OptionChains, futuresChains: FuturesChains, splits: Splits, dividends: Dividends, delistings: Delistings, symbolChanges: SymbolChangedEvents, hasData: Nullable[bool])
        """
        pass

    def __setitem__(self, *args): #cannot find CLR method
        """ x.__setitem__(i, y) <==> x[i]= """
        pass

    Bars = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Market.TradeBars for this slice of data

Get: Bars(self: Slice) -> TradeBars

"""

    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the number of symbols held in this slice

Get: Count(self: Slice) -> int

"""

    Delistings = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.Delistings for this slice of data

Get: Delistings(self: Slice) -> Delistings

"""

    Dividends = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.Dividends for this slice of data

Get: Dividends(self: Slice) -> Dividends

"""

    FutureChains = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.FuturesChains for this slice of data

Get: FutureChains(self: Slice) -> FuturesChains

"""

    FuturesChains = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.FuturesChains for this slice of data

Get: FuturesChains(self: Slice) -> FuturesChains

"""

    GetKeys = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets an System.Collections.Generic.ICollection containing the Symbol objects of the System.Collections.Generic.IDictionary.

"""

    GetValues = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets an System.Collections.Generic.ICollection containing the values in the System.Collections.Generic.IDictionary.

"""

    HasData = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets whether or not this slice has data

Get: HasData(self: Slice) -> bool

"""

    Keys = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets all the symbols in this slice

Get: Keys(self: Slice) -> IReadOnlyList[Symbol]

"""

    OptionChains = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.OptionChains for this slice of data

Get: OptionChains(self: Slice) -> OptionChains

"""

    QuoteBars = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.QuoteBars for this slice of data

Get: QuoteBars(self: Slice) -> QuoteBars

"""

    Splits = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.Splits for this slice of data

Get: Splits(self: Slice) -> Splits

"""

    SymbolChangedEvents = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Market.SymbolChangedEvents for this slice of data

Get: SymbolChangedEvents(self: Slice) -> SymbolChangedEvents

"""

    Ticks = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the QuantConnect.Data.Slice.Ticks for this slice of data

Get: Ticks(self: Slice) -> Ticks

"""

    Time = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets the timestamp for this slice of data

Get: Time(self: Slice) -> DateTime

"""

    Values = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Gets a list of all the data in this slice

Get: Values(self: Slice) -> IReadOnlyList[BaseData]

"""



class SliceExtensions(object):
    """ Provides extension methods to slice enumerables """
    @staticmethod
    def Get(*__args):
        """
        Get(slices: IEnumerable[Slice], symbol: Symbol) -> IEnumerable[TradeBar]
        Get[T](dataDictionaries: IEnumerable[DataDictionary[T]], symbol: Symbol) -> IEnumerable[T]
        Get[T](dataDictionaries: IEnumerable[DataDictionary[T]], symbol: Symbol, field: str) -> IEnumerable[Decimal]
        Get[T](slices: IEnumerable[Slice]) -> IEnumerable[DataDictionary[T]]
        Get[T](slices: IEnumerable[Slice], symbol: Symbol) -> IEnumerable[T]
        Get(slices: IEnumerable[Slice], symbol: Symbol, field: Func[BaseData, Decimal]) -> IEnumerable[Decimal]
        """
        pass

    @staticmethod
    def PushThrough(slices, handler):
        """ PushThrough(slices: IEnumerable[Slice], handler: Action[BaseData]) """
        pass

    @staticmethod
    def PushThroughConsolidators(slices, *__args):
        """ PushThroughConsolidators(slices: IEnumerable[Slice], consolidatorsBySymbol: Dictionary[Symbol, IDataConsolidator])PushThroughConsolidators(slices: IEnumerable[Slice], consolidatorsProvider: Func[Symbol, IDataConsolidator]) """
        pass

    @staticmethod
    def Ticks(slices):
        """ Ticks(slices: IEnumerable[Slice]) -> IEnumerable[Ticks] """
        pass

    @staticmethod
    def ToDoubleArray(decimals):
        """ ToDoubleArray(decimals: IEnumerable[Decimal]) -> Array[float] """
        pass

    @staticmethod
    def TradeBars(slices):
        """ TradeBars(slices: IEnumerable[Slice]) -> IEnumerable[TradeBars] """
        pass

    __all__ = [
        'Get',
        'PushThrough',
        'PushThroughConsolidators',
        'Ticks',
        'ToDoubleArray',
        'TradeBars',
    ]


class SubscriptionDataConfig(object, IEquatable[SubscriptionDataConfig]):
    """
    Subscription data required including the type of data.
    
    SubscriptionDataConfig(objectType: Type, symbol: Symbol, resolution: Resolution, dataTimeZone: DateTimeZone, exchangeTimeZone: DateTimeZone, fillForward: bool, extendedHours: bool, isInternalFeed: bool, isCustom: bool, tickType: Nullable[TickType], isFilteredSubscription: bool, dataNormalizationMode: DataNormalizationMode)
    SubscriptionDataConfig(config: SubscriptionDataConfig, objectType: Type, symbol: Symbol, resolution: Nullable[Resolution], dataTimeZone: DateTimeZone, exchangeTimeZone: DateTimeZone, fillForward: Nullable[bool], extendedHours: Nullable[bool], isInternalFeed: Nullable[bool], isCustom: Nullable[bool], tickType: Nullable[TickType], isFilteredSubscription: Nullable[bool], dataNormalizationMode: Nullable[DataNormalizationMode])
    """
    def Equals(self, *__args):
        """
        Equals(self: SubscriptionDataConfig, other: SubscriptionDataConfig) -> bool
        
            Indicates whether the current object is equal to 
             another object of the same type.
        
        
            other: An object to compare with this object.
            Returns: true if the current object is equal to the other 
             parameter; otherwise, false.
        
        Equals(self: SubscriptionDataConfig, obj: object) -> bool
        
            Determines whether the specified object is equal 
             to the current object.
        
        
            obj: The object to compare with the current object.
            Returns: true if the specified object  is equal to the 
             current object; otherwise, false.
        """
        pass

    def GetHashCode(self):
        """
        GetHashCode(self: SubscriptionDataConfig) -> int
        
            Serves as the default hash function.
            Returns: A hash code for the current object.
        """
        pass

    def GetNormalizedPrice(self, price):
        """
        GetNormalizedPrice(self: SubscriptionDataConfig, price: Decimal) -> Decimal
        
            Normalizes the specified price based on the 
             DataNormalizationMode
        """
        pass

    def ToString(self):
        """
        ToString(self: SubscriptionDataConfig) -> str
        
            Returns a string that represents the current 
             object.
        
            Returns: A string that represents the current object.
        """
        pass

    def __eq__(self, *args): #cannot find CLR method
        """ x.__eq__(y) <==> x==y """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    @staticmethod # known case of __new__
    def __new__(self, *__args):
        """
        __new__(cls: type, objectType: Type, symbol: Symbol, resolution: Resolution, dataTimeZone: DateTimeZone, exchangeTimeZone: DateTimeZone, fillForward: bool, extendedHours: bool, isInternalFeed: bool, isCustom: bool, tickType: Nullable[TickType], isFilteredSubscription: bool, dataNormalizationMode: DataNormalizationMode)
        __new__(cls: type, config: SubscriptionDataConfig, objectType: Type, symbol: Symbol, resolution: Nullable[Resolution], dataTimeZone: DateTimeZone, exchangeTimeZone: DateTimeZone, fillForward: Nullable[bool], extendedHours: Nullable[bool], isInternalFeed: Nullable[bool], isCustom: Nullable[bool], tickType: Nullable[TickType], isFilteredSubscription: Nullable[bool], dataNormalizationMode: Nullable[DataNormalizationMode])
        """
        pass

    def __ne__(self, *args): #cannot find CLR method
        pass

    def __repr__(self, *args): #cannot find CLR method
        """ __repr__(self: object) -> str """
        pass

    def __str__(self, *args): #cannot find CLR method
        pass

    MappedSymbol = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Symbol Mapping: When symbols change over time (e.g. CHASE-> JPM) need to update the symbol requested.

Get: MappedSymbol(self: SubscriptionDataConfig) -> str

Set: MappedSymbol(self: SubscriptionDataConfig) = value
"""

    Symbol = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Symbol of the asset we're requesting: this is really a perm tick!!

Get: Symbol(self: SubscriptionDataConfig) -> Symbol

"""


    Consolidators = None
    DataNormalizationMode = None
    DataTimeZone = None
    ExchangeTimeZone = None
    ExtendedMarketHours = None
    FillDataForward = None
    Increment = None
    IsCustomData = None
    IsFilteredSubscription = None
    IsInternalFeed = None
    Market = None
    PriceScaleFactor = None
    Resolution = None
    SecurityType = None
    SumOfDividends = None
    TickType = None
    Type = None


class SubscriptionDataConfigExtensions(object):
    """
    Helper methods used to determine different configurations properties
                for a given set of QuantConnect.Data.SubscriptionDataConfig
    """
    @staticmethod
    def DataNormalizationMode(subscriptionDataConfigs):
        """ DataNormalizationMode(subscriptionDataConfigs: IEnumerable[SubscriptionDataConfig]) -> DataNormalizationMode """
        pass

    @staticmethod
    def GetBaseDataInstance(config):
        """
        GetBaseDataInstance(config: SubscriptionDataConfig) -> BaseData
        
            Initializes a new instance of the 
             QuantConnect.Data.BaseData type defined in config 
             with the symbol properly set
        """
        pass

    @staticmethod
    def GetHighestResolution(subscriptionDataConfigs):
        """ GetHighestResolution(subscriptionDataConfigs: IEnumerable[SubscriptionDataConfig]) -> Resolution """
        pass

    @staticmethod
    def IsCustomData(subscriptionDataConfigs):
        """ IsCustomData(subscriptionDataConfigs: IEnumerable[SubscriptionDataConfig]) -> bool """
        pass

    @staticmethod
    def IsExtendedMarketHours(subscriptionDataConfigs):
        """ IsExtendedMarketHours(subscriptionDataConfigs: IEnumerable[SubscriptionDataConfig]) -> bool """
        pass

    @staticmethod
    def IsFillForward(subscriptionDataConfigs):
        """ IsFillForward(subscriptionDataConfigs: IEnumerable[SubscriptionDataConfig]) -> bool """
        pass

    @staticmethod
    def SetDataNormalizationMode(subscriptionDataConfigs, mode):
        """ SetDataNormalizationMode(subscriptionDataConfigs: IEnumerable[SubscriptionDataConfig], mode: DataNormalizationMode) """
        pass

    @staticmethod
    def TickerShouldBeMapped(config):
        """
        TickerShouldBeMapped(config: SubscriptionDataConfig) -> bool
        
            Will determine if mapping should be used for this 
             subscription configuration
        
        
            config: The subscription data configuration we are 
             processing
        
            Returns: True if ticker should be mapped
        """
        pass

    __all__ = [
        'DataNormalizationMode',
        'GetBaseDataInstance',
        'GetHighestResolution',
        'IsCustomData',
        'IsExtendedMarketHours',
        'IsFillForward',
        'SetDataNormalizationMode',
        'TickerShouldBeMapped',
    ]


class SubscriptionDataConfigList(List[SubscriptionDataConfig], IList[SubscriptionDataConfig], ICollection[SubscriptionDataConfig], IEnumerable[SubscriptionDataConfig], IEnumerable, IList, ICollection, IReadOnlyList[SubscriptionDataConfig], IReadOnlyCollection[SubscriptionDataConfig]):
    """
    Provides convenient methods for holding several QuantConnect.Data.SubscriptionDataConfig
    
    SubscriptionDataConfigList(symbol: Symbol)
    """
    def SetDataNormalizationMode(self, normalizationMode):
        """
        SetDataNormalizationMode(self: SubscriptionDataConfigList, normalizationMode: DataNormalizationMode)
            Sets the QuantConnect.DataNormalizationMode for 
             all QuantConnect.Data.SubscriptionDataConfig 
             contained in the list
        """
        pass

    def __getitem__(self, *args): #cannot find CLR method
        """ x.__getitem__(y) <==> x[y] """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    def __iter__(self, *args): #cannot find CLR method
        """ __iter__(self: IEnumerable) -> object """
        pass

    @staticmethod # known case of __new__
    def __new__(self, symbol):
        """ __new__(cls: type, symbol: Symbol) """
        pass

    def __setitem__(self, *args): #cannot find CLR method
        """ x.__setitem__(i, y) <==> x[i]= """
        pass

    IsInternalFeed = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Assume that the InternalDataFeed is the same for both QuantConnect.Data.SubscriptionDataConfig

Get: IsInternalFeed(self: SubscriptionDataConfigList) -> bool

"""

    Symbol = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """QuantConnect.Data.SubscriptionDataConfigList.Symbol for which this class holds QuantConnect.Data.SubscriptionDataConfig

Get: Symbol(self: SubscriptionDataConfigList) -> Symbol

"""



class SubscriptionDataSource(object, IEquatable[SubscriptionDataSource]):
    """
    Represents the source location and transport medium for a subscription
    
    SubscriptionDataSource(source: str, transportMedium: SubscriptionTransportMedium)
    SubscriptionDataSource(source: str, transportMedium: SubscriptionTransportMedium, format: FileFormat)
    SubscriptionDataSource(source: str, transportMedium: SubscriptionTransportMedium, format: FileFormat, headers: IEnumerable[KeyValuePair[str, str]])
    """
    def Equals(self, *__args):
        """
        Equals(self: SubscriptionDataSource, other: SubscriptionDataSource) -> bool
        
            Indicates whether the current object is equal to 
             another object of the same type.
        
        
            other: An object to compare with this object.
            Returns: true if the current object is equal to the other 
             parameter; otherwise, false.
        
        Equals(self: SubscriptionDataSource, obj: object) -> bool
        
            Determines whether the specified instance is 
             equal to the current instance.
        
        
            obj: The object to compare with the current object.
            Returns: true if the specified object  is equal to the 
             current object; otherwise, false.
        """
        pass

    def GetHashCode(self):
        """
        GetHashCode(self: SubscriptionDataSource) -> int
        
            Serves as a hash function for a particular type.
            Returns: A hash code for the current System.Object.
        """
        pass

    def ToString(self):
        """
        ToString(self: SubscriptionDataSource) -> str
        
            Returns a string that represents the current 
             object.
        
            Returns: A string that represents the current object.
        """
        pass

    def __eq__(self, *args): #cannot find CLR method
        """ x.__eq__(y) <==> x==y """
        pass

    def __init__(self, *args): #cannot find CLR method
        """ x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature """
        pass

    @staticmethod # known case of __new__
    def __new__(self, source, transportMedium, format=None, headers=None):
        """
        __new__(cls: type, source: str, transportMedium: SubscriptionTransportMedium)
        __new__(cls: type, source: str, transportMedium: SubscriptionTransportMedium, format: FileFormat)
        __new__(cls: type, source: str, transportMedium: SubscriptionTransportMedium, format: FileFormat, headers: IEnumerable[KeyValuePair[str, str]])
        """
        pass

    def __ne__(self, *args): #cannot find CLR method
        pass

    def __repr__(self, *args): #cannot find CLR method
        """ __repr__(self: object) -> str """
        pass

    def __str__(self, *args): #cannot find CLR method
        pass

    Format = None
    Headers = None
    Source = None
    TransportMedium = None


class SubscriptionManager(object):
    """
    Enumerable Subscription Management Class
    
    SubscriptionManager()
    """
    def Add(self, *__args):
        """
        Add(self: SubscriptionManager, symbol: Symbol, resolution: Resolution, timeZone: DateTimeZone, exchangeTimeZone: DateTimeZone, isCustomData: bool, fillDataForward: bool, extendedMarketHours: bool) -> SubscriptionDataConfig
        
            Add Market Data Required (Overloaded method for 
             backwards compatibility).
        
        
            symbol: Symbol of the asset we're like
            resolution: Resolution of Asset Required
            timeZone: The time zone the subscription's data is time 
             stamped in
        
            exchangeTimeZone: Specifies the time zone of the exchange for the 
             security this subscription is for. This
                 
                    is this output time zone, that is, the 
             time zone that will be used on BaseData instances
        
            isCustomData: True if this is custom user supplied data, false 
             for normal QC data
        
            fillDataForward: when there is no data pass the last tradebar 
             forward
        
            extendedMarketHours: Request premarket data as well when true
            Returns: The newly created 
             QuantConnect.Data.SubscriptionDataConfig or 
             existing instance if it already existed
        
        Add(self: SubscriptionManager, dataType: Type, tickType: TickType, symbol: Symbol, resolution: Resolution, dataTimeZone: DateTimeZone, exchangeTimeZone: DateTimeZone, isCustomData: bool, fillDataForward: bool, extendedMarketHours: bool, isInternalFeed: bool, isFilteredSubscription: bool, dataNormalizationMode: DataNormalizationMode) -> SubscriptionDataConfig
        
            Add Market Data Required - generic data typing 
             support as long as Type implements BaseData.
        
        
            dataType: Set the type of the data we're subscribing to.
            tickType: Tick type for the subscription.
            symbol: Symbol of the asset we're like
            resolution: Resolution of Asset Required
            dataTimeZone: The time zone the subscription's data is time 
             stamped in
        
            exchangeTimeZone: Specifies the time zone of the exchange for the 
             security this subscription is for. This
                 
                    is this output time zone, that is, the 
             time zone that will be used on BaseData instances
        
            isCustomData: True if this is custom user supplied data, false 
             for normal QC data
        
            fillDataForward: when there is no data pass the last tradebar 
             forward
        
            extendedMarketHours: Request premarket data as well when true
            isInternalFeed: Set to true to prevent data from this 
             subscription from being sent into the algorithm's
             
                        OnData events
        
            isFilteredSubscription: True if this subscription should have filters 
             applied to it (market hours/user
                        
             filters from security), false otherwise
        
            dataNormalizationMode: Define how data is normalized
            Returns: The newly created 
             QuantConnect.Data.SubscriptionDataConfig or 
             existing instance if it already existed
        """
        pass

    def AddConsolidator(self, symbol, consolidator):
        """
        AddConsolidator(self: SubscriptionManager, symbol: Symbol, consolidator: IDataConsolidator)
            Add a consolidator for the symbol
        
            symbol: Symbol of the asset to consolidate
            consolidator: The consolidator
        """
        pass

    @staticmethod
    def DefaultDataTypes():
        """
        DefaultDataTypes() -> Dictionary[SecurityType, List[TickType]]
        
            Hard code the set of default available data feeds
        """
        pass

    def GetDataTypesForSecurity(self, securityType):
        """
        GetDataTypesForSecurity(self: SubscriptionManager, securityType: SecurityType) -> IReadOnlyList[TickType]
        
            Get the available data types for a security
        """
        pass

    @staticmethod
    def IsSubscriptionValidForConsolidator(subscription, consolidator):
        """
        IsSubscriptionValidForConsolidator(subscription: SubscriptionDataConfig, consolidator: IDataConsolidator) -> bool
        
            Checks if the subscription is valid for the 
             consolidator
        
        
            subscription: The subscription configuration
            consolidator: The consolidator
            Returns: true if the subscription is valid for the 
             consolidator
        """
        pass

    def LookupSubscriptionConfigDataTypes(self, symbolSecurityType, resolution, isCanonical):
        """
        LookupSubscriptionConfigDataTypes(self: SubscriptionManager, symbolSecurityType: SecurityType, resolution: Resolution, isCanonical: bool) -> List[Tuple[Type, TickType]]
        
            Get the data feed types for a given 
             QuantConnect.SecurityTypeQuantConnect.Resolution
        
        
            symbolSecurityType: The QuantConnect.SecurityType used to determine 
             the types
        
            resolution: The resolution of the data requested
            isCanonical: Indicates whether the security is Canonical 
             (future and options)
        
            Returns: Types that should be added to the 
             QuantConnect.Data.SubscriptionDataConfig
        """
        pass

    def RemoveConsolidator(self, symbol, consolidator):
        """
        RemoveConsolidator(self: SubscriptionManager, symbol: Symbol, consolidator: IDataConsolidator)
            Removes the specified consolidator for the symbol
        
            symbol: The symbol the consolidator is receiving data from
            consolidator: The consolidator instance to be removed
        """
        pass

    def SetDataManager(self, subscriptionManager):
        """
        SetDataManager(self: SubscriptionManager, subscriptionManager: IAlgorithmSubscriptionManager)
            Sets the Subscription Manager
        """
        pass

    def __add__(self, *args): #cannot find CLR method
        """ x.__add__(y) <==> x+yx.__add__(y) <==> x+y """
        pass

    AvailableDataTypes = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """The different QuantConnect.TickType each QuantConnect.SecurityType supports

Get: AvailableDataTypes(self: SubscriptionManager) -> Dictionary[SecurityType, List[TickType]]

"""

    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Get the count of assets:

Get: Count(self: SubscriptionManager) -> int

"""

    SubscriptionDataConfigService = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Instance that implements QuantConnect.Interfaces.ISubscriptionDataConfigService

Get: SubscriptionDataConfigService(self: SubscriptionManager) -> ISubscriptionDataConfigService

"""

    Subscriptions = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """Returns an IEnumerable of Subscriptions

Get: Subscriptions(self: SubscriptionManager) -> IEnumerable[SubscriptionDataConfig]

"""



# variables with complex values

